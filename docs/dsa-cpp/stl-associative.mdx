---
title: Associative Containers
description: Sets and Maps in C++ STL
---

## Set

Stores **unique elements** in **sorted order**. Implemented as a balanced binary search tree (Red-Black Tree).

### Basic Operations

```cpp
set<int> st;

st.insert(1);   // {1}
st.emplace(2);  // {1, 2}
st.insert(2);   // {1, 2} - duplicates ignored
st.insert(4);   // {1, 2, 4}
st.insert(3);   // {1, 2, 3, 4} - auto-sorted
```

### Finding Elements

```cpp
set<int> st = {1, 2, 3, 4, 5};

auto it = st.find(3);  // Iterator pointing to 3
auto it = st.find(6);  // Returns st.end() if not found

int cnt = st.count(1); // Returns 1 if exists, 0 otherwise
```

### Erasing Elements

```cpp
set<int> st = {1, 2, 3, 4, 5};

st.erase(5);              // {1, 2, 3, 4} - O(log n)
st.erase(st.find(3));     // {1, 2, 4} - O(1) with iterator

// Range erase [first, last)
auto it1 = st.find(2);
auto it2 = st.find(4);
st.erase(it1, it2);       // {1, 4}
```

### Lower and Upper Bound

These are powerful for finding elements in a range.

```cpp
set<int> st = {1, 3, 5, 7, 9};

auto it = st.lower_bound(4); // Points to 5 (first >= 4)
auto it = st.upper_bound(5); // Points to 7 (first > 5)
```

| Function | Returns |
|----------|---------|
| `lower_bound(x)` | First element ≥ x |
| `upper_bound(x)` | First element > x |

All set operations are **O(log n)**.

---

## Multiset

Like `set`, but allows **duplicate values**.

```cpp
multiset<int> ms;

ms.insert(1);  // {1}
ms.insert(1);  // {1, 1}
ms.insert(1);  // {1, 1, 1}

int cnt = ms.count(1); // 3

ms.erase(1);           // Erases ALL 1s → {}
ms.erase(ms.find(1));  // Erases only ONE 1
```

---

## Unordered Set

Stores unique elements in **no particular order**. Uses hash table internally.

```cpp
unordered_set<int> us;
us.insert(5);
us.insert(2);
us.insert(8);
// Order is unpredictable
```

### Comparison with Set

| Feature | `set` | `unordered_set` |
|---------|-------|-----------------|
| Order | Sorted | Unordered |
| Implementation | Red-Black Tree | Hash Table |
| Average complexity | O(log n) | O(1) |
| Worst case | O(log n) | O(n) — collisions |
| `lower_bound` / `upper_bound` | Yes | No |

**Tip**: Use `unordered_set` for speed when you don't need ordering. Fall back to `set` if you encounter hash collisions (rare but possible with adversarial inputs).

---

## Map

Stores **key-value pairs** with unique keys in **sorted order** (by key).

### Basic Operations

```cpp
map<int, int> mpp;

mpp[1] = 2;           // Key 1 → Value 2
mpp.emplace(3, 4);    // Key 3 → Value 4
mpp.insert({2, 4});   // Key 2 → Value 4

// Complex key/value types
map<int, pair<int, int>> mpp2;
map<pair<int, int>, int> mpp3;
mpp3[{2, 3}] = 10;
```

### Accessing Values

```cpp
cout << mpp[1];  // 2
cout << mpp[5];  // 0 (creates entry if key doesn't exist!)

// Check if key exists first
if (mpp.find(5) != mpp.end()) {
    cout << mpp[5];
}

// Or use count
if (mpp.count(5)) {
    cout << mpp[5];
}
```

### Iterating

```cpp
for (auto it : mpp) {
    cout << it.first << " " << it.second << endl;
}

// Or with structured bindings (C++17)
for (auto [key, value] : mpp) {
    cout << key << " " << value << endl;
}
```

### Finding and Bounds

```cpp
auto it = mpp.find(3);
if (it != mpp.end()) {
    cout << it->second; // Value at key 3
}

auto it = mpp.lower_bound(2); // First key >= 2
auto it = mpp.upper_bound(3); // First key > 3
```

---

## Multimap

Like `map`, but allows **duplicate keys**.

```cpp
multimap<int, string> mm;
mm.insert({1, "one"});
mm.insert({1, "uno"});  // Same key, different value
mm.insert({1, "ek"});   // All three are stored
```

---

## Unordered Map

Stores key-value pairs in **no particular order**. Uses hash table.

```cpp
unordered_map<int, int> umpp;
umpp[1] = 10;
umpp[2] = 20;
```

### Comparison with Map

| Feature | `map` | `unordered_map` |
|---------|-------|-----------------|
| Order | Sorted by key | Unordered |
| Implementation | Red-Black Tree | Hash Table |
| Average complexity | O(log n) | O(1) |
| Worst case | O(log n) | O(n) |
| `lower_bound` / `upper_bound` | Yes | No |

**Strategy**: Use `unordered_map` first for O(1) operations. Switch to `map` if:
- You need sorted traversal
- You're getting TLE due to hash collisions

---

## Ordered vs Unordered Internals

| Type | Data Structure | Requires |
|------|----------------|----------|
| Ordered (`set`, `map`) | Tree (Red-Black) | Comparator (`<` operator) |
| Unordered | Hash Table | Hash function |

This is why custom types need:
- `operator<` for ordered containers
- `std::hash` specialization for unordered containers
