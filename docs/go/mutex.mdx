---
title: Mutex and Synchronization
description: Protecting shared state with sync.Mutex and sync.RWMutex
---

## The Problem: Race Conditions

When multiple goroutines access shared data and at least one modifies it, you have a race condition. The result depends on timing and is unpredictable.

```go
// DANGER: Race condition
var counter int

func main() {
    for i := 0; i < 1000; i++ {
        go func() {
            counter++  // Not atomic: read, increment, write
        }()
    }
    
    time.Sleep(time.Second)
    fmt.Println(counter)  // Unpredictable: might be 980, 995, 1000...
}
```

The increment `counter++` is actually three operations:
1. Read current value
2. Add 1
3. Write new value

Goroutines can interleave these operations, causing lost updates.

---

## Detecting Race Conditions

Go has a built-in race detector:

```bash
go run -race main.go
go test -race ./...
```

Output shows where races occur:

```
WARNING: DATA RACE
Read at 0x... by goroutine 7:
  main.main.func1()
      /path/main.go:10 +0x...

Previous write at 0x... by goroutine 6:
  main.main.func1()
      /path/main.go:10 +0x...
```

---

## sync.Mutex

A mutex (mutual exclusion) ensures only one goroutine can access a critical section at a time.

```go
import "sync"

var (
    counter int
    mu      sync.Mutex
)

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            mu.Lock()         // Acquire lock
            counter++         // Critical section
            mu.Unlock()       // Release lock
        }()
    }
    
    wg.Wait()
    fmt.Println(counter)  // Always 1000
}
```

### How Mutex Works

- `Lock()`: Acquires the lock. If already locked, blocks until available.
- `Unlock()`: Releases the lock. Allows one waiting goroutine to proceed.

Only one goroutine can hold the lock at a time. Others wait.

---

## Using Defer for Unlock

Always use `defer` to ensure the mutex is unlocked, even if the function panics or returns early:

```go
func increment() {
    mu.Lock()
    defer mu.Unlock()  // Guaranteed to run
    
    // Complex logic that might return early or panic
    if someCondition {
        return  // mu.Unlock() still runs
    }
    
    counter++
}
```

This pattern prevents deadlocks from forgotten unlocks.

---

## Mutex with Structs

Embed the mutex in the struct it protects:

```go
type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}

func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}

func main() {
    counter := &SafeCounter{}
    
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Println(counter.Value())  // 1000
}
```

---

## sync.RWMutex

For read-heavy workloads, `RWMutex` allows multiple readers OR one writer:

```go
type SafeMap struct {
    mu   sync.RWMutex
    data map[string]int
}

func (m *SafeMap) Get(key string) (int, bool) {
    m.mu.RLock()         // Read lock: multiple readers allowed
    defer m.mu.RUnlock()
    val, ok := m.data[key]
    return val, ok
}

func (m *SafeMap) Set(key string, value int) {
    m.mu.Lock()          // Write lock: exclusive access
    defer m.mu.Unlock()
    m.data[key] = value
}
```

### RWMutex Methods

| Method | Description |
|--------|-------------|
| `Lock()` | Exclusive write lock. Blocks until no readers or writers. |
| `Unlock()` | Release write lock. |
| `RLock()` | Shared read lock. Multiple readers can hold simultaneously. |
| `RUnlock()` | Release one read lock. |

### When to Use RWMutex

- Many more reads than writes
- Read operations are non-trivial (would benefit from concurrency)
- For simple operations, regular `Mutex` might be faster due to lower overhead

---

## Common Patterns

### Protecting a Map

Maps are not safe for concurrent use. Always protect with a mutex:

```go
type Cache struct {
    mu    sync.RWMutex
    items map[string]interface{}
}

func NewCache() *Cache {
    return &Cache{
        items: make(map[string]interface{}),
    }
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    val, ok := c.items[key]
    return val, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.items[key] = value
}

func (c *Cache) Delete(key string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    delete(c.items, key)
}
```

### sync.Map for High-Contention Maps

For maps with heavy concurrent access, consider `sync.Map`:

```go
var cache sync.Map

// Store
cache.Store("key", "value")

// Load
value, ok := cache.Load("key")

// Delete
cache.Delete("key")

// LoadOrStore: load if exists, otherwise store
actual, loaded := cache.LoadOrStore("key", "default")
```

`sync.Map` is optimized for:
- Keys written once but read many times
- Multiple goroutines read/write disjoint sets of keys

---

## Avoiding Deadlocks

### Deadlock: Forgetting to Unlock

```go
func bad() {
    mu.Lock()
    if err := doSomething(); err != nil {
        return  // DEADLOCK: Lock never released
    }
    mu.Unlock()
}

func good() {
    mu.Lock()
    defer mu.Unlock()  // Always released
    if err := doSomething(); err != nil {
        return
    }
}
```

### Deadlock: Locking Twice

```go
func bad() {
    mu.Lock()
    mu.Lock()  // DEADLOCK: Same goroutine tries to lock twice
}
```

Mutex is not reentrant. A goroutine cannot lock a mutex it already holds.

### Deadlock: Lock Ordering

```go
// Goroutine 1     // Goroutine 2
mu1.Lock()         mu2.Lock()
mu2.Lock()         mu1.Lock()  // DEADLOCK
```

Always acquire locks in the same order across all goroutines.

---

## sync.Once

Run initialization exactly once, even with concurrent goroutines:

```go
var (
    instance *Database
    once     sync.Once
)

func GetDatabase() *Database {
    once.Do(func() {
        instance = &Database{}
        instance.Connect()
    })
    return instance
}
```

`once.Do` guarantees:
- The function runs exactly once
- All goroutines see the result after it completes
- Subsequent calls return immediately

---

## Combining Mutex with WaitGroup and Defer

A complete pattern for safe concurrent operations:

```go
func processItems(items []Item) Results {
    var (
        mu      sync.Mutex
        wg      sync.WaitGroup
        results Results
    )
    
    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            
            result := process(item)
            
            mu.Lock()
            defer mu.Unlock()
            results = append(results, result)
        }(item)
    }
    
    wg.Wait()
    return results
}
```

Key points:
- `defer wg.Done()` ensures the counter decrements even on panic
- `defer mu.Unlock()` ensures the lock is released even on panic
- Item is passed as parameter to avoid loop variable capture

---

## Atomic Operations

For simple counters, `sync/atomic` is faster than mutex:

```go
import "sync/atomic"

var counter int64

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    
    wg.Wait()
    fmt.Println(atomic.LoadInt64(&counter))  // 1000
}
```

Common atomic operations:

| Function | Description |
|----------|-------------|
| `AddInt64(&x, delta)` | Atomically add |
| `LoadInt64(&x)` | Atomically read |
| `StoreInt64(&x, val)` | Atomically write |
| `SwapInt64(&x, new)` | Atomically swap, return old |
| `CompareAndSwapInt64(&x, old, new)` | Swap if current == old |

Use atomics for:
- Simple counters
- Flags
- When performance is critical

Use mutex for:
- Complex data structures
- Multiple related updates
- Operations that need to read and then write

---

## Key Points

1. Race conditions occur when multiple goroutines access shared data concurrently
2. Use `go run -race` to detect races
3. `sync.Mutex` provides exclusive access to a critical section
4. `sync.RWMutex` allows multiple readers OR one exclusive writer
5. Always use `defer mu.Unlock()` to prevent deadlocks
6. Never lock a mutex twice from the same goroutine
7. Use `sync/atomic` for simple counter operations
8. Embed mutex in structs they protect for clarity
