---
title: Viewport Example
description: A Bubble Tea todo application with scrollable viewport and alt screen
---

## Todo App with Viewport

This example adds a scrollable viewport for long lists and uses the alternate screen buffer.

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type Todo struct {
	Text      string `json:"text"`
	Completed bool   `json:"completed"`
}

func getDataPath() string {
	home, _ := os.UserHomeDir()
	return filepath.Join(home, ".todo-tui.json")
}

func loadTodos() []Todo {
	data, err := os.ReadFile(getDataPath())
	if err != nil {
		return []Todo{
			{Text: "Buy groceries", Completed: false},
			{Text: "Walk the dog", Completed: false},
			{Text: "Learn Bubble Tea", Completed: false},
		}
	}

	var todos []Todo
	if err := json.Unmarshal(data, &todos); err != nil {
		return []Todo{}
	}

	return todos
}

func saveTodos(todos []Todo) error {
	data, err := json.MarshalIndent(todos, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(getDataPath(), data, 0644)
}

var (
	purple   = lipgloss.Color("99")
	gray     = lipgloss.Color("245")
	darkGray = lipgloss.Color("236")
	white    = lipgloss.Color("255")
	green    = lipgloss.Color("76")

	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(purple).
			MarginBottom(1)

	itemStyle = lipgloss.NewStyle().
			PaddingLeft(2)

	selectedItemStyle = lipgloss.NewStyle().
				PaddingLeft(0).
				Foreground(purple).
				Bold(true)

	checkedStyle = lipgloss.NewStyle().
			Foreground(green).
			Bold(true)

	uncheckedStyle = lipgloss.NewStyle().
			Foreground(gray)

	completedTextStyle = lipgloss.NewStyle().
				Strikethrough(true).
				Foreground(gray)

	statsStyle = lipgloss.NewStyle().
			Foreground(purple).
			Bold(true).
			MarginBottom(1)

	helpStyle = lipgloss.NewStyle().
			Foreground(gray).
			MarginTop(1)
)

func countCompleted(todos []Todo) int {
	count := 0
	for _, t := range todos {
		if t.Completed {
			count++
		}
	}

	return count
}

type model struct {
	todos     []Todo
	cursor    int
	selected  map[int]struct{}
	textInput textinput.Model
	adding    bool
	viewport  viewport.Model
	ready     bool
}

func initialModel() model {
	ti := textinput.New()
	ti.Placeholder = "What needs to be done?"
	ti.CharLimit = 100
	ti.Width = 40

	return model{
		todos:     loadTodos(),
		textInput: ti,
		adding:    false,
		ready:     false,
	}
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	if m.adding {
		switch msg := msg.(type) {
		case tea.KeyMsg:
			switch msg.String() {
			case "enter":
				value := m.textInput.Value()
				if value != "" {
					m.todos = append(m.todos, Todo{Text: value, Completed: false})
					saveTodos(m.todos)
				}
				m.textInput.Reset()
				m.adding = false
				m.viewport.SetContent(m.renderContent())
				return m, nil
			case "esc":
				m.textInput.Reset()
				m.adding = false
				return m, nil
			}
		}
		m.textInput, cmd = m.textInput.Update(msg)
		return m, cmd
	}

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		headerHeight := 3
		footerHeight := 3

		if !m.ready {
			m.viewport = viewport.New(msg.Width, msg.Height-headerHeight-footerHeight)
			m.viewport.SetContent(m.renderContent())
			m.ready = true
		} else {
			m.viewport.Width = msg.Width
			m.viewport.Height = msg.Height - headerHeight - footerHeight
			m.viewport.SetContent(m.renderContent())
		}

	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		case "up", "k":
			if m.cursor > 0 {
				m.cursor--
				m.viewport.SetContent(m.renderContent())
			}
		case "down", "j":
			if m.cursor < len(m.todos)-1 {
				m.cursor++
				m.viewport.SetContent(m.renderContent())
			}
		case "enter", " ":
			if len(m.todos) > 0 {
				m.todos[m.cursor].Completed = !m.todos[m.cursor].Completed
				saveTodos(m.todos)
				m.viewport.SetContent(m.renderContent())
			}
		case "a":
			m.adding = true
			m.textInput.Focus()
			return m, textinput.Blink
		case "d":
			if len(m.todos) > 0 {
				m.todos = append(m.todos[:m.cursor], m.todos[m.cursor+1:]...)
				if m.cursor >= len(m.todos) && m.cursor > 0 {
					m.cursor--
				}
				saveTodos(m.todos)
				m.viewport.SetContent(m.renderContent())
			}
		}
	}

	m.viewport, cmd = m.viewport.Update(msg)
	cmds = append(cmds, cmd)

	return m, tea.Batch(cmds...)
}

func (m model) renderContent() string {
	var s string

	total := len(m.todos)
	completed := countCompleted(m.todos)
	if total > 0 {
		s += statsStyle.Render(fmt.Sprintf("Progress: %d/%d completed", completed, total)) + "\n\n"
	}

	if total == 0 {
		s += itemStyle.Render("All clear! Press 'a' to add a todo.") + "\n"
		return s
	}

	for i, todo := range m.todos {
		cursor := "  "
		if m.cursor == i {
			cursor = ">"
		}

		var checkbox string
		if todo.Completed {
			checkbox = checkedStyle.Render("[✓]")
		} else {
			checkbox = uncheckedStyle.Render("[ ]")
		}

		var text string
		if todo.Completed {
			text = completedTextStyle.Render(todo.Text)
		} else if m.cursor == i {
			text = selectedItemStyle.Render(todo.Text)
		} else {
			text = itemStyle.Render(todo.Text)
		}

		s += fmt.Sprintf("%s %s %s\n", cursor, checkbox, text)
	}

	return s
}

func (m model) View() string {
	if m.adding {
		s := titleStyle.Render("Todo List") + "\n\n"
		s += "New todo:\n"
		s += m.textInput.View() + "\n\n"
		s += helpStyle.Render("enter: save • esc: cancel")
		return s
	}
	if !m.ready {
		return "Loading..."
	}
	header := titleStyle.Render("Todo List") + "\n"
	footer := helpStyle.Render("─────────────────────────────────────\n")
	footer += helpStyle.Render("↑/↓: navigate • space: toggle • a: add • d: delete • q: quit")
	return header + m.viewport.View() + "\n" + footer
}

func main() {
	p := tea.NewProgram(
		initialModel(),
		tea.WithAltScreen(),
	)
	if _, err := p.Run(); err != nil {
		fmt.Printf("Error: %v", err)
		os.Exit(1)
	}
}
```

---

## Key Additions Explained

### Viewport Component

```go
import "github.com/charmbracelet/bubbles/viewport"

type model struct {
    viewport viewport.Model
    ready    bool
}
```

The viewport provides a scrollable content area with automatic overflow handling.

### Window Size Handling

```go
case tea.WindowSizeMsg:
    headerHeight := 3
    footerHeight := 3

    if !m.ready {
        m.viewport = viewport.New(msg.Width, msg.Height-headerHeight-footerHeight)
        m.viewport.SetContent(m.renderContent())
        m.ready = true
    } else {
        m.viewport.Width = msg.Width
        m.viewport.Height = msg.Height - headerHeight - footerHeight
        m.viewport.SetContent(m.renderContent())
    }
```

| Concept | Purpose |
|---------|---------|
| `tea.WindowSizeMsg` | Received when terminal resizes |
| `ready` flag | Tracks if viewport is initialized |
| `headerHeight/footerHeight` | Reserve space for fixed UI elements |

### Alternate Screen Buffer

```go
p := tea.NewProgram(
    initialModel(),
    tea.WithAltScreen(),
)
```

`tea.WithAltScreen()` switches to the alternate screen buffer, preserving the user's terminal history.

### Content Rendering Pattern

```go
func (m model) renderContent() string {
    var s string
    // Build content string
    return s
}
```

Separating content rendering from `View()` allows updating viewport content independently:

```go
m.viewport.SetContent(m.renderContent())
```

### Viewport Update Propagation

```go
m.viewport, cmd = m.viewport.Update(msg)
cmds = append(cmds, cmd)
return m, tea.Batch(cmds...)
```

The viewport must receive all messages to handle scrolling and other internal state.
