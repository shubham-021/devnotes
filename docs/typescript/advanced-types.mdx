---
title: Advanced Types
description: Deep dive into never, conditional types, and the infer keyword
---

## The Never Type

In TypeScript, `never` represents the absence of a value — a type that should never occur. It's the "empty set" of the type system.

### Never in Unions

When `never` appears in a union, it disappears:

```typescript
type Example = string | never // evaluates to `string`
```

Think of types as mathematical sets:

| Type | Set Analogy |
|------|-------------|
| `string` | Set of all string values |
| `never` | Empty set (∅) |
| `any` | Universal set (U) |

The union of any set with an empty set is just that set. But `any` absorbs everything:

```typescript
type A = string | never  // string
type B = string | any    // any
```

This behavior makes `never` useful as an **escape hatch** in conditional types — unwanted branches can return `never` and simply vanish from the final type.

---

## Conditional Types

Conditional types let you create types that change based on conditions. They work like ternary operators, but at the type level.

### The Extends Keyword

The `extends` keyword expresses a constraint. `T extends K` means "T is assignable to K":

```typescript
type IsString<T> = T extends string ? true : false

type A = IsString<"hello">  // true
type B = IsString<42>       // false
```

### Chaining Conditions

You can chain conditionals just like nested ternaries:

```typescript
type TypeName<T> = 
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  T extends Function ? "function" :
  "unknown"

type A = TypeName<"hello">     // "string"
type B = TypeName<false>       // "boolean"
type C = TypeName<() => void>  // "function"
```

---

## Distributive Conditional Types

When a conditional type acts on a **union**, TypeScript distributes the condition over each member:

```typescript
type NonNullable<T> = T extends null | undefined ? never : T

type Input = string | null | undefined
type Result = NonNullable<Input>  // string
```

Here's what happens internally:

```typescript
// TypeScript evaluates each union member separately:
type Step1 = string extends null | undefined ? never : string     // string
type Step2 = null extends null | undefined ? never : null         // never
type Step3 = undefined extends null | undefined ? never : undefined // never

// Then combines them:
type Final = string | never | never  // string
```

The `never` types vanish, leaving only `string`.

### Building Extract and Exclude

This distributive behavior is how the built-in `Extract` and `Exclude` utilities work:

```typescript
type Extract<T, U> = T extends U ? T : never
type Exclude<T, U> = T extends U ? never : T

type Numbers = 1 | 2 | 3 | 4 | 5
type SmallNumbers = Extract<Numbers, 1 | 2 | 3>  // 1 | 2 | 3
type LargeNumbers = Exclude<Numbers, 1 | 2 | 3>  // 4 | 5
```

---

## The Infer Keyword

The `infer` keyword lets you **capture** a type within a conditional type. It can only be used inside an `extends` clause.

### Basic Pattern

```typescript
type Unwrap<T> = T extends Array<infer U> ? U : T

type A = Unwrap<string[]>   // string
type B = Unwrap<number[]>   // number
type C = Unwrap<boolean>    // boolean (not an array, returned as-is)
```

The `infer U` declares a type variable that captures whatever type is inside the array.

### How ReturnType Works

The built-in `ReturnType` utility uses `infer` to extract a function's return type:

```typescript
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any

type A = ReturnType<() => void>            // void
type B = ReturnType<() => string | number> // string | number
type C = ReturnType<(x: number) => boolean> // boolean
```

---

## Infer Use Cases

### Extracting Array Element Types

```typescript
type ElementType<T> = T extends readonly (infer U)[] ? U : never

type A = ElementType<string[]>          // string
type B = ElementType<readonly number[]> // number
type C = ElementType<[1, 2, 3]>         // 1 | 2 | 3
```

### Flattening Nested Arrays

Using recursion with `infer` to unwrap deeply nested arrays:

```typescript
type Flatten<T> = T extends Array<infer U> ? Flatten<U> : T

type Nested = number[][][]
type Flat = Flatten<Nested>  // number
```

TypeScript recursively unwraps until it reaches a non-array type.

### Extracting from Tuples

You can destructure tuples at the type level:

```typescript
type First<T extends any[]> = T extends [infer F, ...any[]] ? F : never
type Last<T extends any[]> = T extends [...any[], infer L] ? L : never
type Rest<T extends any[]> = T extends [any, ...infer R] ? R : never

type Tuple = [string, number, boolean]

type A = First<Tuple>  // string
type B = Last<Tuple>   // boolean
type C = Rest<Tuple>   // [number, boolean]
```

### Converting Tuples to Unions

A recursive type that converts a tuple into a union of its elements:

```typescript
type TupleToUnion<T extends any[]> = T extends [infer U, ...infer Rest]
  ? U | TupleToUnion<Rest>
  : never

type Colors = ["red", "green", "blue"]
type Color = TupleToUnion<Colors>  // "red" | "green" | "blue"
```

### Practical Example: Type-Safe Tuple Head

```typescript
type TupleToUnion<T extends any[]> = T extends [infer U, ...infer Rest]
  ? U | TupleToUnion<Rest>
  : never

function getHead<T extends any[]>(tuple: [...T]): TupleToUnion<T> {
  return tuple[0]
}

const a = getHead(["hello", 42])        // string | number
const b = getHead([true, false, true])  // boolean
```

---

## Quick Reference

| Pattern | Purpose | Example |
|---------|---------|---------|
| `T extends U ? A : B` | Conditional type | `T extends string ? true : false` |
| `infer R` | Capture a type | `T extends Array<infer R> ? R : T` |
| `never` in union | Disappears | `string \| never` → `string` |
| Distributive | Loops over union | `NonNullable<string \| null>` → `string` |

### Key Insights

1. **`never`** is the escape hatch — use it to filter out unwanted types
2. **`extends`** checks assignability, not equality
3. **`infer`** can only appear in the `extends` clause
4. Conditional types **distribute** over unions automatically
5. Combine these patterns to build powerful type utilities
